// 二分图博弈
// 给出一张二分图和起始点H，A和B轮流操作（A先选），每次只能选与上个被选择的点相邻的点，且不能选择已选择过的点，无法选点的人输掉。
// 如果二分图的最大匹配!!!一定!!!包含H（所有的最大匹配都包含H），那么先手必胜，否则先手必败。

// 模型：棋盘模型
// 两人轮流移动 n 个物品中的一个一步，n 个物品的位置不能出现已经出现过的状态
// 此时可以建立二分图，位置和是奇数的状态放在左边点的集合，偶数的放在右边点的集合
// 也可以借助集合来考虑，比如n = 3时对应 3 个维度


// 可以先用黑白染色法判断博弈模型是否是二分图，然后判断H是否被所有的最大匹配包含

// 二分图的最大匹配可以使用Dinic或者匈牙利算法求得
// 如果采用Dinic，不要根据有没有点建两次图。而是在建图时把涉及 H 点的边存下来，跑完第一次Dinic后再建这些边，第二次Dinic看有没有增加流量。
// 也可以先跑一遍Dinic并减去相应的流，如果加上涉及 H 的边之后再跑一边Dinic最大流不是0，就说明H在最大匹配中

int maxFlow();
void wk() {
    // 建图
    maxFlow();
    // 加边
    (maxFlow() ? "Alice" : "Bob");
}